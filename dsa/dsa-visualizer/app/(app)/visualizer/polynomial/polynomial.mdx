# POLYNOMIAL MULTIPLICATION â€“ COMPLETE CONTENT

## ğŸ”¹ What is a Polynomial?

A polynomial is an expression of the form:

`P(x) = aâ‚™xâ¿ + aâ‚™â‚‹â‚xâ¿â»Â¹ + ... + aâ‚x + aâ‚€`

Each term has:

- Coefficient (a)
- Exponent (power of x)

Example:

`P(x) = 3xÂ² + 2x + 1`

## ğŸ”¹ What is Polynomial Multiplication?

Polynomial multiplication means multiplying two polynomials to produce a new polynomial.

Example:

`P(x) = 2x + 3`

`Q(x) = x + 4`

Multiplication:

`(2x + 3)(x + 4)`

`= 2xÂ² + 8x + 3x + 12`

`= 2xÂ² + 11x + 12`

## ğŸ”¹ Why Important in DSA?

- Implemented using arrays or linked lists
- Used in compiler design
- Used in symbolic computation
- Common linked list lab problem

## ğŸ”¹ Array Representation

Polynomial:

`3xÂ² + 2x + 1`

Stored as:

```
Index (Exponent): 2 1 0
Array:           3 2 1
```

## ğŸ”¹ Multiplication Algorithm (Array Method)

Steps:

1. Store both polynomials in coefficient arrays
2. Result degree = sum of degrees
3. Multiply each term of first polynomial with each term of second
4. Add coefficients of same exponent

## ğŸ”¹ Algorithm Formula

If

`P[i] = coefficient of x^i`

`Q[j] = coefficient of x^j`

Then result:

`R[i+j] += P[i] * Q[j]`

## ğŸ”¹ Time Complexity

O(n Ã— m)

`n` = degree of first polynomial

`m` = degree of second polynomial

---

## ğŸ’» POLYNOMIAL MULTIPLICATION CODE

### ğŸ Python

```python
def multiply(P, Q):
    n, m = len(P), len(Q)
    R = [0]*(n+m-1)

    for i in range(n):
        for j in range(m):
            R[i+j] += P[i]*Q[j]

    return R

# Example: P = 3xÂ²+2x+1 â†’ [1,2,3]
P = [1,2,3]
Q = [4,1]      # x+4 â†’ [4,1]

R = multiply(P,Q)
print(R)  # Result: [4,9,14,3] â†’ 3xÂ³+14xÂ²+9x+4
```

### ğŸ’» C

```c
#include <stdio.h>

int main() {
    int P[] = {1,2,3}; // 3xÂ²+2x+1
    int Q[] = {4,1};   // x+4

    int n=3, m=2;
    int R[5]={0};

    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            R[i+j] += P[i]*Q[j];

    for(int i=n+m-2;i>=0;i--)
        printf("%dx^%d ", R[i], i);

    return 0;
}
```

### âš™ï¸ C++

```cpp
#include <iostream>
using namespace std;

int main() {
    int P[] = {1,2,3};
    int Q[] = {4,1};

    int n=3, m=2;
    int R[5]={0};

    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            R[i+j] += P[i]*Q[j];

    for(int i=n+m-2;i>=0;i--)
        cout << R[i] << "x^" << i << " ";
}
```

### â˜• Java

```java
class PolyMultiply {
    public static void main(String[] args) {
        int P[] = {1,2,3};
        int Q[] = {4,1};

        int n=P.length, m=Q.length;
        int R[] = new int[n+m-1];

        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                R[i+j] += P[i]*Q[j];

        for(int i=n+m-2;i>=0;i--)
            System.out.print(R[i]+"x^"+i+" ");
    }
}
```

## ğŸ”¹ Output Example

`3x^3 14x^2 9x^1 4x^0`

Which means:

`3xÂ³ + 14xÂ² + 9x + 4`# Polynomial Multiplication

Polynomial multiplication using linked lists is an efficient way to handle algebraic operations on polynomials of any degree.

## Implementation

Here's how polynomials are represented and multiplied using linked lists:

```c
typedef struct Term {
    int coefficient;
    int exponent;
    struct Term* next;
} Term;

typedef struct {
    Term* head;
} Polynomial;

// Create new term
Term* createTerm(int coeff, int exp) {
    Term* term = (Term*)malloc(sizeof(Term));
    term->coefficient = coeff;
    term->exponent = exp;
    term->next = NULL;
    return term;
}

// Insert term into polynomial
void insertTerm(Polynomial* poly, int coeff, int exp) {
    Term* newTerm = createTerm(coeff, exp);

    if (!poly->head || exp > poly->head->exponent) {
        newTerm->next = poly->head;
        poly->head = newTerm;
        return;
    }

    Term* current = poly->head;
    while (current->next && current->next->exponent > exp) {
        current = current->next;
    }

    newTerm->next = current->next;
    current->next = newTerm;
}

// Multiply two polynomials
Polynomial* multiply(Polynomial* p1, Polynomial* p2) {
    Polynomial* result = (Polynomial*)malloc(sizeof(Polynomial));
    result->head = NULL;

    Term* term1 = p1->head;
    while (term1) {
        Term* term2 = p2->head;
        while (term2) {
            int coeff = term1->coefficient * term2->coefficient;
            int exp = term1->exponent + term2->exponent;
            insertTerm(result, coeff, exp);
            term2 = term2->next;
        }
        term1 = term1->next;
    }

    return result;
}
```

## Algorithm Steps

1. **Representation**
   - Each term has coefficient, exponent, and next pointer
   - Terms are stored in descending order of exponents
   - Zero coefficients are typically omitted

2. **Multiplication Process**
   - Multiply each term of first polynomial with each term of second
   - Add exponents and multiply coefficients
   - Combine like terms (same exponents)
   - Maintain descending order of exponents

3. **Time Complexity**
   - For polynomials of length m and n: O(m*n)
   - Additional space complexity: O(m*n)

## Example

For polynomials:
- P1(x) = 3xÂ² + 2x + 1
- P2(x) = 2x + 1

The multiplication P1(x) * P2(x) results in:
- (3xÂ²)(2x) = 6xÂ³
- (3xÂ²)(1) = 3xÂ²
- (2x)(2x) = 4xÂ²
- (2x)(1) = 2x
- (1)(2x) = 2x
- (1)(1) = 1

Combining like terms:
- Result = 6xÂ³ + 7xÂ² + 4x + 1

## Applications

1. **Algebraic Computations**
   - Symbolic mathematics
   - Computer algebra systems
   - Mathematical modeling

2. **Signal Processing**
   - Convolution operations
   - Digital filters
   - Frequency analysis

3. **Numerical Methods**
   - Interpolation
   - Curve fitting
   - Approximation algorithms

## Advantages of Linked List Implementation

1. **Dynamic Size**
   - No fixed size limitation
   - Efficient memory usage
   - Easy to add/remove terms

2. **Ordered Storage**
   - Terms maintained in descending order
   - Efficient combination of like terms
   - Easy to print in standard form

3. **Sparse Polynomial Handling**
   - Only non-zero terms stored
   - Efficient for sparse polynomials
   - Reduced memory usage
