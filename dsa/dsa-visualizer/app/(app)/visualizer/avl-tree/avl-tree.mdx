# AVL TREE ‚Äì COMPLETE CONTENT

## üîπ What is an AVL Tree?

An AVL Tree (named after Adelson-Velsky & Landis) is a:

- Self-balancing Binary Search Tree

In an AVL Tree, for every node:

**Balance Factor = Height(left subtree) ‚àí Height(right subtree)**

And this value must be -1, 0, or +1.

If not, the tree automatically rotates to maintain balance.

## üîπ Why AVL Tree?

Normal BST can become skewed (like a linked list) ‚Üí $O(n)$ search.

AVL Tree keeps height logarithmic, ensuring:

- Insert ‚Üí O(log n)
- Delete ‚Üí O(log n)
- Search ‚Üí O(log n)

## üîπ Balance Factor (BF)

<div className="my-6">
  <table>
    <thead>
      <tr>
        <th className="pr-12">BF Value</th>
        <th>Meaning</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="pr-12">+1</td>
        <td>Left heavy</td>
      </tr>
      <tr>
        <td className="pr-12">0</td>
        <td>Balanced</td>
      </tr>
      <tr>
        <td className="pr-12">-1</td>
        <td>Right heavy</td>
      </tr>
      <tr>
        <td className="pr-12">&gt;1 or &lt;-1</td>
        <td>Rotation needed</td>
      </tr>
    </tbody>
  </table>
</div>

---

# üîÅ AVL ROTATIONS

To rebalance tree after insertion/deletion:

## 1) Right Rotation (LL Case)

```
      z               y
     /               / \
    y      ‚Üí        x   z
   /
  x
```

## 2) Left Rotation (RR Case)

```
  z                   y
   \                 / \
    y     ‚Üí         z   x
     \
      x
```

## 3) Left-Right Rotation (LR Case)

```
   z              z              x
  /              /              / \
 y      ‚Üí       x      ‚Üí       y   z
  \            /
   x          y
```

## 4) Right-Left Rotation (RL Case)

```
 z               z               x
  \               \             / \
   y      ‚Üí        x    ‚Üí      z   y
  /                 \
 x                   y
```

---

## üîπ AVL Insertion Steps

1. Insert node like normal BST
2. Update height
3. Check balance factor
4. Apply suitable rotation

## üîπ Time Complexity

<div className="my-6">
  <table>
    <thead>
      <tr>
        <th className="pr-12">Operation</th>
        <th>Time</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="pr-12">Search</td>
        <td>O(log n)</td>
      </tr>
      <tr>
        <td className="pr-12">Insert</td>
        <td>O(log n)</td>
      </tr>
      <tr>
        <td className="pr-12">Delete</td>
        <td>O(log n)</td>
      </tr>
    </tbody>
  </table>
</div>

## üéØ Key Advantages

- Always balanced
- Guaranteed fast operations
- No skewed structure

## üéØ Interview One-Liner

"An AVL Tree is a self-balancing BST where the height difference between left and right subtrees is at most one, maintained using rotations."

---

## üíª Minimal AVL Tree Code (Insertion + Inorder)

Below is a compact working AVL implementation.

(Sufficient for lab / exam)

### üêç Python

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = self.right = None
        self.height = 1

def height(n): return n.height if n else 0

def rotate_right(y):
    x = y.left
    T2 = x.right
    x.right = y
    y.left = T2
    y.height = 1 + max(height(y.left), height(y.right))
    x.height = 1 + max(height(x.left), height(x.right))
    return x

def rotate_left(x):
    y = x.right
    T2 = y.left
    y.left = x
    x.right = T2
    x.height = 1 + max(height(x.left), height(x.right))
    y.height = 1 + max(height(y.left), height(y.right))
    return y

def balance(n): return height(n.left) - height(n.right)

def insert(node, key):
    if not node: return Node(key)
    if key < node.key:
        node.left = insert(node.left, key)
    else:
        node.right = insert(node.right, key)

    node.height = 1 + max(height(node.left), height(node.right))
    b = balance(node)

    # LL
    if b > 1 and key < node.left.key:
        return rotate_right(node)
    # RR
    if b < -1 and key > node.right.key:
        return rotate_left(node)
    # LR
    if b > 1 and key > node.left.key:
        node.left = rotate_left(node.left)
        return rotate_right(node)
    # RL
    if b < -1 and key < node.right.key:
        node.right = rotate_right(node.right)
        return rotate_left(node)

    return node

def inorder(root):
    if root:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)

# Demo
root = None
for x in [10,20,30,40,50,25]:
    root = insert(root, x)

inorder(root)
```

## üß† What Happens in Demo?

Inserting: 10,20,30,40,50,25

AVL automatically rotates ‚Üí Balanced Tree

Inorder output ‚Üí Sorted: 10 20 25 30 40 50# AVL Tree

An AVL tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.

## Basic schema of depth first traversals:

- `Pre-Order Traversal`: Parent Left Right
- `In-Order Traversal`: Left Parent Right
- `Post-order Traversal`: Left Right Parent

## Implementation

Here's a basic implementation in C:

```c
typedef struct Node {
    int value;
    struct Node* left;
    struct Node* right;
    int height;
} Node;

// Create a new node
Node* createNode(int value) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->value = value;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;
    return node;
}

// Get height of a node
int getHeight(Node* node) {
    if (node == NULL) return 0;
    return node->height;
}

// Get balance factor
int getBalance(Node* node) {
    if (node == NULL) return 0;
    return getHeight(node->left) - getHeight(node->right);
}

// Right rotation
Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x;
}

// Left rotation
Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y;
}

// Insert a node
Node* insert(Node* node, int value) {
    // 1. Perform normal BST insertion
    if (node == NULL)
        return createNode(value);

    if (value < node->value)
        node->left = insert(node->left, value);
    else if (value > node->value)
        node->right = insert(node->right, value);
    else // Equal values not allowed
        return node;

    // 2. Update height
    node->height = max(getHeight(node->left), getHeight(node->right)) + 1;

    // 3. Get balance factor
    int balance = getBalance(node);

    // Left Left Case
    if (balance > 1 && value < node->left->value)
        return rightRotate(node);

    // Right Right Case
    if (balance < -1 && value > node->right->value)
        return leftRotate(node);

    // Left Right Case
    if (balance > 1 && value > node->left->value) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balance < -1 && value < node->right->value) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}
```

## Traversal Operations

```c
// Pre-order traversal
void preOrder(Node* root) {
    if (root != NULL) {
        printf("%d ", root->value);
        preOrder(root->left);
        preOrder(root->right);
    }
}

// In-order traversal
void inOrder(Node* root) {
    if (root != NULL) {
        inOrder(root->left);
        printf("%d ", root->value);
        inOrder(root->right);
    }
}

// Post-order traversal
void postOrder(Node* root) {
    if (root != NULL) {
        postOrder(root->left);
        postOrder(root->right);
        printf("%d ", root->value);
    }
}
```

## Properties
- For each node, the heights of its left and right subtrees differ by at most 1
- All operations (insertion, deletion, search) take O(log n) time
- Balance factor = height(left subtree) - height(right subtree)
- Balance factor must be -1, 0, or 1 for all nodes

## Rotations
- Left Rotation: Used when right subtree becomes higher
- Right Rotation: Used when left subtree becomes higher
- Left-Right Rotation: Combination used for more complex imbalances
- Right-Left Rotation: Combination used for more complex imbalances

## Applications
- Databases where frequent insertions and deletions occur
- Memory management systems
- File systems requiring balanced tree structures
