# What is Huffman Coding?

Huffman Coding is a lossless data compression algorithm that assigns:

- Shorter binary codes to frequent characters
- Longer binary codes to rare characters

This reduces total storage size.

## ðŸ”¹ Key Idea

More frequent characters â†’ shorter codes

Less frequent characters â†’ longer codes

## ðŸ”¹ Type of Algorithm

Greedy Algorithm

It always combines the two lowest-frequency nodes first.

## ðŸ”¹ Why Huffman Coding?

- Efficient text compression
- Used in ZIP, JPEG, MP3, PDF
- Reduces file size without data loss

## ðŸ”¹ Basic Architecture

```
Characters + Frequencies
        â†“
Build Huffman Tree
        â†“
Generate Binary Codes
        â†“
Encode Text
```

---

# ðŸŒ³ HUFFMAN TREE

## ðŸ”¹ What is a Huffman Tree?

A binary tree where:

- Each leaf node represents a character
- Path from root to leaf gives its binary code
- Left edge â†’ 0
- Right edge â†’ 1

## ðŸ”¹ Prefix Property

No code is a prefix of another

Ensures unique decoding

Example:

```
A â†’ 0
B â†’ 10
C â†’ 110
D â†’ 111
```

No code starts with another full code.

---

# ðŸ”¹ HUFFMAN ALGORITHM STEPS

1. Calculate frequency of each character
2. Create a leaf node for each character
3. Insert all nodes into a Min Heap (priority queue)
4. Repeat until one node remains:
   - Remove two nodes with smallest frequencies
   - Create a new internal node with frequency = sum
   - Insert new node back into heap
5. Remaining node becomes root of Huffman Tree
6. Assign 0 (left) and 1 (right) to generate codes

---

# ðŸ”¹ EXAMPLE

Characters and frequencies:

<div className="my-6">
  <table>
    <thead>
      <tr>
        <th className="pr-12">Character</th>
        <th>Frequency</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="pr-12">A</td>
        <td>5</td>
      </tr>
      <tr>
        <td className="pr-12">B</td>
        <td>9</td>
      </tr>
      <tr>
        <td className="pr-12">C</td>
        <td>12</td>
      </tr>
      <tr>
        <td className="pr-12">D</td>
        <td>13</td>
      </tr>
      <tr>
        <td className="pr-12">E</td>
        <td>16</td>
      </tr>
      <tr>
        <td className="pr-12">F</td>
        <td>45</td>
      </tr>
    </tbody>
  </table>
</div>

After building Huffman Tree, sample codes:

```
F â†’ 0
C â†’ 100
D â†’ 101
A â†’ 1100
B â†’ 1101
E â†’ 111
```

## ðŸ”¹ Compression Benefit

Original fixed-length encoding (3 bits each):

`6 chars Ã— 3 bits = 18 bits`

Huffman encoded:

Total â‰ˆ 9 bits average

â†’ 50% compression

## ðŸ”¹ TIME COMPLEXITY

<div className="my-6">
  <table>
    <thead>
      <tr>
        <th className="pr-12">Step</th>
        <th>Time</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="pr-12">Build heap</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td className="pr-12">Build tree</td>
        <td>O(n log n)</td>
      </tr>
      <tr>
        <td className="pr-12">Generate codes</td>
        <td>O(n)</td>
      </tr>
    </tbody>
  </table>
</div>

## ðŸ”¹ APPLICATIONS

- File compression (ZIP, GZIP)
- Image compression (JPEG, PNG)
- Audio compression (MP3)
- Data transmission

## ðŸŽ¯ INTERVIEW ONE-LINER

"Huffman Coding is a greedy compression algorithm that builds a binary tree based on character frequencies to generate optimal prefix-free variable-length codes."

---

## ðŸ’» SIMPLE HUFFMAN CODING CODE (Python)

```python
import heapq

class Node:
    def __init__(self,freq,char=None,left=None,right=None):
        self.freq=freq
        self.char=char
        self.left=left
        self.right=right
    def __lt__(self,other):
        return self.freq < other.freq

def build_huffman(freq):
    heap=[]
    for ch,f in freq.items():
        heapq.heappush(heap,Node(f,ch))

    while len(heap)>1:
        n1=heapq.heappop(heap)
        n2=heapq.heappop(heap)
        merged=Node(n1.freq+n2.freq,None,n1,n2)
        heapq.heappush(heap,merged)

    return heap[0]

def generate_codes(root,code="",codes={}):
    if root:
        if root.char:
            codes[root.char]=code
        generate_codes(root.left,code+"0",codes)
        generate_codes(root.right,code+"1",codes)
    return codes

# Demo
freq={'A':5,'B':9,'C':12,'D':13,'E':16,'F':45}
root=build_huffman(freq)
codes=generate_codes(root)
print(codes)
```

## ðŸ”¹ OUTPUT SAMPLE

```
{'F': '0', 'C': '100', 'D': '101', 'A': '1100', 'B': '1101', 'E': '111'}
```
